// Generates Typescript models
using System.Linq;
using System.Collections.Generic;

// Leprechaun provides the following:
// ConfigurationName - The @name from the Leprechaun element, or the "namespace" if not defined, from the Sitecore serialization config file
// GenericRootNamespace - The "rootNamespace" from the Leprechaun config file
// Templates - The templates from Sitecore
// Code - The output file writer
// Log - Logger to use during generation, output appears in the console

// Template information provided:
// TemplateInfo - Path, Id, Name, HelpText, BaseTemplateIds, OwnFields (Shouldn't need to be using this)
// RootNamespace - ???
// Path - Path from TemplateInfo
// Id - ID from TemplateInfo
// Name - Name from TemplateInfo
// HelpText - HelpText from TemplateInfo if defined, otherwise 'Represents the {Name} field ({Id}).'
// CodeName - A unique name for this template, usable as a name for a C# class. e.g. for "Foo Bar" this would be "FooBar"
// RelativeNamespace - Gets a namespace-formatted relative path from the root template path to this template
//                      e.g. if root is /Foo, and this template's path is /Foo/Bar/Baz/Quux, this would be "Bar.Baz"
// Namespace - Gets the full namespace for the template (e.g. RootNamespace.RelativeNamespace)
// FullTypeName - Gets the full type name, qualified by namespace, of this template
//                  e.g. RootNamespace.RelativeNamespace.CodeName
// OwnFields - The template's fields that should get passed to code generation
// BaseTemplates - All known immediate templates implemented by this type (transitive inheritance is not included eg a -> b -> c, will have b but not c for a)
// AllFields - All fields that make up this template, including all base templates' fields

Log.Debug($"Emitting TypeScript interfaces for {ConfigurationName}...");

Code.AppendLine($@"
/**
 * <auto-generated>
 *     This code was generated by a tool.
 *
 *     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 * </auto-generated>
 */

{RenderImportStatements()}
{RenderTemplates()}
");
public string RenderImportStatements()
{
    var localCode = new System.Text.StringBuilder();

    var foundModules = new System.Collections.Generic.HashSet<string>();

    var currentRootNamespace = Templates.First().RootNamespace;

    localCode.AppendLine($@"// @ts-ignore Prevent noUnusedLocals from triggering an error, we import all core field types to minimize changing to code generation.");
    localCode.AppendLine(@"import { ItemExt } from ""lib/_.Sitecore.Override""");
    localCode.AppendLine($@"// @ts-ignore Prevent noUnusedLocals from triggering an error, we import all core field types to minimize changing to code generation.");
    localCode.AppendLine($@"import {{ ComponentRendering, RouteData, Field, ImageField, FileField, LinkField }} from '@sitecore-jss/sitecore-jss-nextjs';");
    localCode.AppendLine($@"// @ts-ignore Prevent noUnusedLocals from triggering an error, we import all core field types to minimize changing to code generation.");
    localCode.AppendLine($@"import {{ ComponentProps }} from '@/lib/component-props';");

    foreach (var template in GetBaseTemplates(Templates))
    {
        if (template.RootNamespace != currentRootNamespace && !foundModules.Contains(template.RootNamespace))
        {
            foundModules.Add(template.RootNamespace);
            var split = ((string)template.RootNamespace).Split('.');
            var layer = split[0];
            var module = split[1];
            localCode.AppendLine($@"import {{ {layer} }} from ""./{layer}.{module}.model""");
        }
    }

    return localCode.ToString();
}
public string RenderTemplates()
{
    var localCode = new System.Text.StringBuilder();

    // Render the Item mappings
    var oldNamespace = "";
    foreach (var template in Templates)
    {
        if (template.Namespace != oldNamespace)
        {
            if (!string.IsNullOrWhiteSpace(oldNamespace))
            {
                localCode.AppendLine($@"}}");
            }
            localCode.AppendLine($@"export namespace {template.Namespace} {{");
            oldNamespace = template.Namespace;
        }

        localCode.AppendLine($@"    export type {template.CodeName} = {RenderBaseInterfaces(template)}{{");
        if (IsRenderingParameters(template))
        {
            localCode.AppendLine($@"        {RenderInterfaceParamsFields(template)}");
        }
        else
        {
            localCode.AppendLine($@"        {RenderInterfaceFields(template)}");
        }
        localCode.AppendLine($@"    }}");
    }
    if (Templates.Any())
    {
        localCode.AppendLine($@"}}");
    }

    return localCode.ToString();
}

public string RenderBaseInterfaces(TemplateCodeGenerationMetadata template)
{
    var bases = new System.Collections.Generic.List<string>(template.BaseTemplates.Count + 1);

    // At this time, we don't have sitecore standard fields for components
    if (IsBaseComponent(template) || IsBaseCard(template))
    {
        bases.Add("ComponentProps");
    }
    else if (IsBaseElement(template))
    {
        bases.Add("ItemExt");
    }

    foreach (var baseTemplate in template.BaseTemplates)
    {
        bases.Add($@"
        {baseTemplate.Namespace}.{baseTemplate.CodeName}");
    }

    return bases.Any() ? $"{string.Join(" & ", bases)} & " : "";
}

public string RenderInterfaceFields(TemplateCodeGenerationMetadata template)
{
    var localCode = new System.Text.StringBuilder();

    var fieldsCode = new System.Text.StringBuilder();
    foreach (var field in template.OwnFields)
    {
        fieldsCode.AppendLine($@"
            /**
            * {field.HelpText}
            */
            {GetFieldCodeName(field)}: {GetFieldType(field)};");
    }
    localCode.AppendLine($@"fields?: {{ {fieldsCode}        }}");

    return localCode.ToString();
}


public string RenderInterfaceParamsFields(TemplateCodeGenerationMetadata template)
{
    var localCode = new System.Text.StringBuilder();

    // Rendering parameters are always strings
    foreach (var field in template.OwnFields)
    {
        localCode.AppendLine($@"
            /**
            * {field.HelpText}
            */
            {GetFieldCodeName(field)}: string;");
    }

    return localCode.ToString();
}

public string GetFieldCodeName(TemplateFieldCodeGenerationMetadata field, string suffix = "")
{
    // Check if field name needs to be quoted and add quotes as needed
    var name = System.Text.RegularExpressions.Regex.IsMatch(field.Name, "[ -]+") ? $"\"{field.Name}{suffix}\"" : field.Name + suffix;

    // Item reference fields will return null if it is blank, but all other types will not be null
    if (GetFieldType(field) == "ItemExt")
    {
        name += "?";
    }
    return name;
}

public string GetFieldType(TemplateFieldCodeGenerationMetadata field)
{
    switch (field.Type.ToLower())
    {
        //case "tristate":
        //    return "TriState";
        case "checkbox":
            return "Field<boolean>";

        case "date":
        case "datetime":
            return "Field<string>";

        case "number":
            return "Field<number>";

        case "integer":
            return "Field<number>";

        case "multiroot treelist":
        case "multilist with search":
        case "treelist":
        case "treelistex":
        case "treelist descriptive":
        case "checklist":
        case "multilist":
            return "ItemExt[]";
        case "grouped droplink":
        case "droplink":
        case "lookup":
        case "droptree":
        case "reference":
        case "tree":
            return "ItemExt";

        case "file":
            return "FileField";

        case "image":
            return "ImageField";

        case "rich text":
        case "html":
            return "Field<string>";

        case "general link":
            return "LinkField";

        case "single-line text":
        case "multi-line text":
        case "frame":
        case "text":
        case "memo":
        case "droplist":
        case "grouped droplist":
        case "valuelookup":
            return "Field<string>";
        default:
            return "Field<string>";
    }
}

public bool IsOrInheritsFromTemplate(TemplateCodeGenerationMetadata template, string templateId)
{
    var isTemplate = template.Id == System.Guid.Parse(templateId);

    if (isTemplate)
    {
        return true;
    }

    foreach (var baseTemplate in template.BaseTemplates)
    {
        if (IsOrInheritsFromTemplate(baseTemplate, templateId))
        {
            return true;
        }
    }

    return false;
}

public List<TemplateCodeGenerationMetadata> GetBaseTemplates(IEnumerable<TemplateCodeGenerationMetadata> templates, List<TemplateCodeGenerationMetadata> foundTemplates = null)
{
    if (foundTemplates == null)
    {
        foundTemplates = new List<TemplateCodeGenerationMetadata>();
    }

    foreach (var template in templates)
    {
        if (!foundTemplates.Any(_ => _.Id == template.Id))
        {
            foundTemplates.Add(template);
            GetBaseTemplates(template.BaseTemplates, foundTemplates);
        }
    }

    return foundTemplates;
}

public bool IsRenderingParameters(TemplateCodeGenerationMetadata template)
{
    return IsOrInheritsFromTemplate(template, "d24bb6f7-6088-4cbf-a4cc-5746e8ae78a9");
}

public bool IsBaseComponent(TemplateCodeGenerationMetadata template)
{
    return template.Id == System.Guid.Parse("{b61a1d20-9ee5-4ccb-9e0d-24a97e58d293}");
}

public bool IsBaseCard(TemplateCodeGenerationMetadata template)
{
    return template.Id == System.Guid.Parse("{c153ec5e-57b3-4354-b86a-c2a8ad172b96}");
}

public bool IsBaseElement(TemplateCodeGenerationMetadata template)
{
    return template.Id == System.Guid.Parse("{17dc7cee-994d-4dc7-80bc-357ef53c3708}");
}
